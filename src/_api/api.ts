/* tslint:disable */
/* eslint-disable */
/**
 * Medical Office Api
 * API REST
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AvaliableDatesResponse
 */
export interface AvaliableDatesResponse {
    /**
     * 
     * @type {number}
     * @memberof AvaliableDatesResponse
     */
    total: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof AvaliableDatesResponse
     */
    results: Array<string>;
}
/**
 * 
 * @export
 * @interface CancelMedicalAppointmentDTO
 */
export interface CancelMedicalAppointmentDTO {
    /**
     * 
     * @type {string}
     * @memberof CancelMedicalAppointmentDTO
     */
    reason: string;
}
/**
 * 
 * @export
 * @interface CreateMedicalAppointmentDTO
 */
export interface CreateMedicalAppointmentDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateMedicalAppointmentDTO
     */
    date: string;
    /**
     * 
     * @type {number}
     * @memberof CreateMedicalAppointmentDTO
     */
    scheduleId: number;
    /**
     * 
     * @type {number}
     * @memberof CreateMedicalAppointmentDTO
     */
    userId: number;
}
/**
 * 
 * @export
 * @interface CreateModalDTO
 */
export interface CreateModalDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateModalDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateModalDTO
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof CreateModalDTO
     */
    description: string;
    /**
     * 
     * @type {number}
     * @memberof CreateModalDTO
     */
    isMain: number;
    /**
     * 
     * @type {number}
     * @memberof CreateModalDTO
     */
    isActive: number;
    /**
     * 
     * @type {number}
     * @memberof CreateModalDTO
     */
    order: number;
}
/**
 * 
 * @export
 * @interface CreateOfficeDTO
 */
export interface CreateOfficeDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateOfficeDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOfficeDTO
     */
    place: string;
    /**
     * 
     * @type {string}
     * @memberof CreateOfficeDTO
     */
    phone: string;
    /**
     * 
     * @type {number}
     * @memberof CreateOfficeDTO
     */
    isActive: number;
}
/**
 * 
 * @export
 * @interface CreateScheduleDTO
 */
export interface CreateScheduleDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateScheduleDTO
     */
    date: string;
    /**
     * 
     * @type {string}
     * @memberof CreateScheduleDTO
     */
    dateEnd: string;
    /**
     * 
     * @type {string}
     * @memberof CreateScheduleDTO
     */
    startHour: string;
    /**
     * 
     * @type {string}
     * @memberof CreateScheduleDTO
     */
    endHour: string;
    /**
     * 
     * @type {number}
     * @memberof CreateScheduleDTO
     */
    isActive: number;
    /**
     * 
     * @type {number}
     * @memberof CreateScheduleDTO
     */
    specialityId: number;
    /**
     * 
     * @type {number}
     * @memberof CreateScheduleDTO
     */
    specialistId: number;
}
/**
 * 
 * @export
 * @interface CreateSpecialityDTO
 */
export interface CreateSpecialityDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateSpecialityDTO
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof CreateSpecialityDTO
     */
    isActive: number;
    /**
     * 
     * @type {number}
     * @memberof CreateSpecialityDTO
     */
    officeId: number;
}
/**
 * 
 * @export
 * @interface CreateUserDTO
 */
export interface CreateUserDTO {
    /**
     * 
     * @type {string}
     * @memberof CreateUserDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDTO
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDTO
     */
    phone: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDTO
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDTO
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserDTO
     */
    legalId: string;
    /**
     * 
     * @type {number}
     * @memberof CreateUserDTO
     */
    familyUserId: number;
    /**
     * 
     * @type {Roles}
     * @memberof CreateUserDTO
     */
    profile: Roles;
}
/**
 * 
 * @export
 * @interface CreateUserResponse
 */
export interface CreateUserResponse {
    /**
     * 
     * @type {number}
     * @memberof CreateUserResponse
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof CreateUserResponse
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserResponse
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserResponse
     */
    phone: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserResponse
     */
    legalId: string;
    /**
     * 
     * @type {object}
     * @memberof CreateUserResponse
     */
    profile: object;
}
/**
 * 
 * @export
 * @interface LoginDTO
 */
export interface LoginDTO {
    /**
     * 
     * @type {string}
     * @memberof LoginDTO
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof LoginDTO
     */
    password: string;
}
/**
 * 
 * @export
 * @interface LoginUserReponseDTO
 */
export interface LoginUserReponseDTO {
    /**
     * 
     * @type {string}
     * @memberof LoginUserReponseDTO
     */
    token_type: string;
    /**
     * 
     * @type {string}
     * @memberof LoginUserReponseDTO
     */
    access_token: string;
}
/**
 * 
 * @export
 * @interface PaginatedResponse
 */
export interface PaginatedResponse {
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponse
     */
    total: number;
    /**
     * 
     * @type {number}
     * @memberof PaginatedResponse
     */
    limit: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedResponse
     */
    offset: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PaginatedResponse
     */
    response: Array<string>;
}
/**
 * 
 * @export
 * @interface PayloadDto
 */
export interface PayloadDto {
    /**
     * 
     * @type {number}
     * @memberof PayloadDto
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof PayloadDto
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof PayloadDto
     */
    profile: string;
    /**
     * 
     * @type {number}
     * @memberof PayloadDto
     */
    iat: number;
    /**
     * 
     * @type {number}
     * @memberof PayloadDto
     */
    exp: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum PublicRoles {
    Student = 'student',
    Employee = 'employee',
    Family = 'family',
    MedicalSpecialist = 'medical_specialist'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum Roles {
    Myseft = 'myseft',
    BackendValidation = 'backend_validation',
    Admin = 'admin',
    Admin2 = 'admin_2',
    Student = 'student',
    Employee = 'employee',
    Family = 'family',
    MedicalSpecialist = 'medical_specialist'
}

/**
 * 
 * @export
 * @interface SigninDTO
 */
export interface SigninDTO {
    /**
     * 
     * @type {string}
     * @memberof SigninDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SigninDTO
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof SigninDTO
     */
    phone: string;
    /**
     * 
     * @type {string}
     * @memberof SigninDTO
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof SigninDTO
     */
    legalId: string;
    /**
     * 
     * @type {number}
     * @memberof SigninDTO
     */
    familyUserId: number;
    /**
     * 
     * @type {PublicRoles}
     * @memberof SigninDTO
     */
    profile: PublicRoles;
}
/**
 * 
 * @export
 * @interface UpdateMedicalAppointmentDTO
 */
export interface UpdateMedicalAppointmentDTO {
    /**
     * 
     * @type {string}
     * @memberof UpdateMedicalAppointmentDTO
     */
    report: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateMedicalAppointmentDTO
     */
    refferedSpecialityId: number;
}
/**
 * 
 * @export
 * @interface UpdatePasswordDTO
 */
export interface UpdatePasswordDTO {
    /**
     * 
     * @type {string}
     * @memberof UpdatePasswordDTO
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof UpdatePasswordDTO
     */
    password: string;
}
/**
 * 
 * @export
 * @interface UpdateUserDTO
 */
export interface UpdateUserDTO {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDTO
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDTO
     */
    phone: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDTO
     */
    legalId: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserDTO
     */
    password: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateUserDTO
     */
    familyUserId: number;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileAuth: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LoginDTO} loginDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAuth: async (loginDTO: LoginDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginDTO' is not null or undefined
            assertParamExists('loginAuth', 'loginDTO', loginDTO)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SigninDTO} signinDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinAuth: async (signinDTO: SigninDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'signinDTO' is not null or undefined
            assertParamExists('signinAuth', 'signinDTO', signinDTO)
            const localVarPath = `/auth/signin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signinDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfileAuth(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayloadDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfileAuth(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {LoginDTO} loginDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginAuth(loginDTO: LoginDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginUserReponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginAuth(loginDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SigninDTO} signinDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signinAuth(signinDTO: SigninDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginUserReponseDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signinAuth(signinDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileAuth(options?: any): AxiosPromise<PayloadDto> {
            return localVarFp.getProfileAuth(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LoginDTO} loginDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginAuth(loginDTO: LoginDTO, options?: any): AxiosPromise<LoginUserReponseDTO> {
            return localVarFp.loginAuth(loginDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SigninDTO} signinDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signinAuth(signinDTO: SigninDTO, options?: any): AxiosPromise<LoginUserReponseDTO> {
            return localVarFp.signinAuth(signinDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getProfileAuth(options?: any) {
        return AuthApiFp(this.configuration).getProfileAuth(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LoginDTO} loginDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public loginAuth(loginDTO: LoginDTO, options?: any) {
        return AuthApiFp(this.configuration).loginAuth(loginDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SigninDTO} signinDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public signinAuth(signinDTO: SigninDTO, options?: any) {
        return AuthApiFp(this.configuration).signinAuth(signinDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DatabasesApi - axios parameter creator
 * @export
 */
export const DatabasesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backupDatabaseApi: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/databases/backup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDatabaseApi: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/databases/restore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabasesApi - functional programming interface
 * @export
 */
export const DatabasesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabasesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async backupDatabaseApi(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.backupDatabaseApi(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreDatabaseApi(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreDatabaseApi(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatabasesApi - factory interface
 * @export
 */
export const DatabasesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabasesApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        backupDatabaseApi(options?: any): AxiosPromise<void> {
            return localVarFp.backupDatabaseApi(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDatabaseApi(options?: any): AxiosPromise<void> {
            return localVarFp.restoreDatabaseApi(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabasesApi - object-oriented interface
 * @export
 * @class DatabasesApi
 * @extends {BaseAPI}
 */
export class DatabasesApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabasesApi
     */
    public backupDatabaseApi(options?: any) {
        return DatabasesApiFp(this.configuration).backupDatabaseApi(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabasesApi
     */
    public restoreDatabaseApi(options?: any) {
        return DatabasesApiFp(this.configuration).restoreDatabaseApi(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HealthCheckApi - axios parameter creator
 * @export
 */
export const HealthCheckApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheckApp: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthCheckApi - functional programming interface
 * @export
 */
export const HealthCheckApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthCheckApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthCheckApp(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthCheckApp(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HealthCheckApi - factory interface
 * @export
 */
export const HealthCheckApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthCheckApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheckApp(options?: any): AxiosPromise<void> {
            return localVarFp.healthCheckApp(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthCheckApi - object-oriented interface
 * @export
 * @class HealthCheckApi
 * @extends {BaseAPI}
 */
export class HealthCheckApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthCheckApi
     */
    public healthCheckApp(options?: any) {
        return HealthCheckApiFp(this.configuration).healthCheckApp(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MedicalAppointmentsApi - axios parameter creator
 * @export
 */
export const MedicalAppointmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {CancelMedicalAppointmentDTO} cancelMedicalAppointmentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelMedicalAppointments: async (id: number, cancelMedicalAppointmentDTO: CancelMedicalAppointmentDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelMedicalAppointments', 'id', id)
            // verify required parameter 'cancelMedicalAppointmentDTO' is not null or undefined
            assertParamExists('cancelMedicalAppointments', 'cancelMedicalAppointmentDTO', cancelMedicalAppointmentDTO)
            const localVarPath = `/appointments/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelMedicalAppointmentDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateMedicalAppointmentDTO} createMedicalAppointmentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMedicalAppointments: async (createMedicalAppointmentDTO: CreateMedicalAppointmentDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createMedicalAppointmentDTO' is not null or undefined
            assertParamExists('createMedicalAppointments', 'createMedicalAppointmentDTO', createMedicalAppointmentDTO)
            const localVarPath = `/appointments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMedicalAppointmentDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMedicalAppointments: async (limit?: number, offset?: number, where?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/appointments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneMedicalAppointments: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOneMedicalAppointments', 'id', id)
            const localVarPath = `/appointments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateMedicalAppointmentDTO} updateMedicalAppointmentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMedicalAppointments: async (id: number, updateMedicalAppointmentDTO: UpdateMedicalAppointmentDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateMedicalAppointments', 'id', id)
            // verify required parameter 'updateMedicalAppointmentDTO' is not null or undefined
            assertParamExists('updateMedicalAppointments', 'updateMedicalAppointmentDTO', updateMedicalAppointmentDTO)
            const localVarPath = `/appointments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMedicalAppointmentDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MedicalAppointmentsApi - functional programming interface
 * @export
 */
export const MedicalAppointmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MedicalAppointmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id 
         * @param {CancelMedicalAppointmentDTO} cancelMedicalAppointmentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelMedicalAppointments(id: number, cancelMedicalAppointmentDTO: CancelMedicalAppointmentDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelMedicalAppointments(id, cancelMedicalAppointmentDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateMedicalAppointmentDTO} createMedicalAppointmentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMedicalAppointments(createMedicalAppointmentDTO: CreateMedicalAppointmentDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMedicalAppointmentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMedicalAppointments(createMedicalAppointmentDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMedicalAppointments(limit?: number, offset?: number, where?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMedicalAppointments(limit, offset, where, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOneMedicalAppointments(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMedicalAppointmentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOneMedicalAppointments(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateMedicalAppointmentDTO} updateMedicalAppointmentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMedicalAppointments(id: number, updateMedicalAppointmentDTO: UpdateMedicalAppointmentDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateMedicalAppointmentDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMedicalAppointments(id, updateMedicalAppointmentDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MedicalAppointmentsApi - factory interface
 * @export
 */
export const MedicalAppointmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MedicalAppointmentsApiFp(configuration)
    return {
        /**
         * 
         * @param {number} id 
         * @param {CancelMedicalAppointmentDTO} cancelMedicalAppointmentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelMedicalAppointments(id: number, cancelMedicalAppointmentDTO: CancelMedicalAppointmentDTO, options?: any): AxiosPromise<void> {
            return localVarFp.cancelMedicalAppointments(id, cancelMedicalAppointmentDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateMedicalAppointmentDTO} createMedicalAppointmentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMedicalAppointments(createMedicalAppointmentDTO: CreateMedicalAppointmentDTO, options?: any): AxiosPromise<CreateMedicalAppointmentDTO> {
            return localVarFp.createMedicalAppointments(createMedicalAppointmentDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMedicalAppointments(limit?: number, offset?: number, where?: string, options?: any): AxiosPromise<PaginatedResponse> {
            return localVarFp.getAllMedicalAppointments(limit, offset, where, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneMedicalAppointments(id: number, options?: any): AxiosPromise<CreateMedicalAppointmentDTO> {
            return localVarFp.getOneMedicalAppointments(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateMedicalAppointmentDTO} updateMedicalAppointmentDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMedicalAppointments(id: number, updateMedicalAppointmentDTO: UpdateMedicalAppointmentDTO, options?: any): AxiosPromise<UpdateMedicalAppointmentDTO> {
            return localVarFp.updateMedicalAppointments(id, updateMedicalAppointmentDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MedicalAppointmentsApi - object-oriented interface
 * @export
 * @class MedicalAppointmentsApi
 * @extends {BaseAPI}
 */
export class MedicalAppointmentsApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {CancelMedicalAppointmentDTO} cancelMedicalAppointmentDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MedicalAppointmentsApi
     */
    public cancelMedicalAppointments(id: number, cancelMedicalAppointmentDTO: CancelMedicalAppointmentDTO, options?: any) {
        return MedicalAppointmentsApiFp(this.configuration).cancelMedicalAppointments(id, cancelMedicalAppointmentDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateMedicalAppointmentDTO} createMedicalAppointmentDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MedicalAppointmentsApi
     */
    public createMedicalAppointments(createMedicalAppointmentDTO: CreateMedicalAppointmentDTO, options?: any) {
        return MedicalAppointmentsApiFp(this.configuration).createMedicalAppointments(createMedicalAppointmentDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [where] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MedicalAppointmentsApi
     */
    public getAllMedicalAppointments(limit?: number, offset?: number, where?: string, options?: any) {
        return MedicalAppointmentsApiFp(this.configuration).getAllMedicalAppointments(limit, offset, where, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MedicalAppointmentsApi
     */
    public getOneMedicalAppointments(id: number, options?: any) {
        return MedicalAppointmentsApiFp(this.configuration).getOneMedicalAppointments(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {UpdateMedicalAppointmentDTO} updateMedicalAppointmentDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MedicalAppointmentsApi
     */
    public updateMedicalAppointments(id: number, updateMedicalAppointmentDTO: UpdateMedicalAppointmentDTO, options?: any) {
        return MedicalAppointmentsApiFp(this.configuration).updateMedicalAppointments(id, updateMedicalAppointmentDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ModalsApi - axios parameter creator
 * @export
 */
export const ModalsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateModalDTO} createModalDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModals: async (createModalDTO: CreateModalDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createModalDTO' is not null or undefined
            assertParamExists('createModals', 'createModalDTO', createModalDTO)
            const localVarPath = `/modals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createModalDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModals: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteModals', 'id', id)
            const localVarPath = `/modals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllModals: async (limit?: number, offset?: number, where?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/modals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneModals: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOneModals', 'id', id)
            const localVarPath = `/modals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {CreateModalDTO} createModalDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateModals: async (id: number, createModalDTO: CreateModalDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateModals', 'id', id)
            // verify required parameter 'createModalDTO' is not null or undefined
            assertParamExists('updateModals', 'createModalDTO', createModalDTO)
            const localVarPath = `/modals/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createModalDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModalsApi - functional programming interface
 * @export
 */
export const ModalsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ModalsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateModalDTO} createModalDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createModals(createModalDTO: CreateModalDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateModalDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createModals(createModalDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteModals(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteModals(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllModals(limit?: number, offset?: number, where?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllModals(limit, offset, where, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOneModals(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateModalDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOneModals(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {CreateModalDTO} createModalDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateModals(id: number, createModalDTO: CreateModalDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateModalDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateModals(id, createModalDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ModalsApi - factory interface
 * @export
 */
export const ModalsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ModalsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateModalDTO} createModalDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModals(createModalDTO: CreateModalDTO, options?: any): AxiosPromise<CreateModalDTO> {
            return localVarFp.createModals(createModalDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModals(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteModals(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllModals(limit?: number, offset?: number, where?: string, options?: any): AxiosPromise<PaginatedResponse> {
            return localVarFp.getAllModals(limit, offset, where, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneModals(id: number, options?: any): AxiosPromise<CreateModalDTO> {
            return localVarFp.getOneModals(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {CreateModalDTO} createModalDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateModals(id: number, createModalDTO: CreateModalDTO, options?: any): AxiosPromise<CreateModalDTO> {
            return localVarFp.updateModals(id, createModalDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ModalsApi - object-oriented interface
 * @export
 * @class ModalsApi
 * @extends {BaseAPI}
 */
export class ModalsApi extends BaseAPI {
    /**
     * 
     * @param {CreateModalDTO} createModalDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModalsApi
     */
    public createModals(createModalDTO: CreateModalDTO, options?: any) {
        return ModalsApiFp(this.configuration).createModals(createModalDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModalsApi
     */
    public deleteModals(id: number, options?: any) {
        return ModalsApiFp(this.configuration).deleteModals(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [where] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModalsApi
     */
    public getAllModals(limit?: number, offset?: number, where?: string, options?: any) {
        return ModalsApiFp(this.configuration).getAllModals(limit, offset, where, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModalsApi
     */
    public getOneModals(id: number, options?: any) {
        return ModalsApiFp(this.configuration).getOneModals(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {CreateModalDTO} createModalDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModalsApi
     */
    public updateModals(id: number, createModalDTO: CreateModalDTO, options?: any) {
        return ModalsApiFp(this.configuration).updateModals(id, createModalDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OfficesApi - axios parameter creator
 * @export
 */
export const OfficesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateOfficeDTO} createOfficeDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOffices: async (createOfficeDTO: CreateOfficeDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOfficeDTO' is not null or undefined
            assertParamExists('createOffices', 'createOfficeDTO', createOfficeDTO)
            const localVarPath = `/offices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOfficeDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOffices: async (limit?: number, offset?: number, where?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/offices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneOffices: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOneOffices', 'id', id)
            const localVarPath = `/offices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logicDisableOffices: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('logicDisableOffices', 'id', id)
            const localVarPath = `/offices/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {CreateOfficeDTO} createOfficeDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOffices: async (id: number, createOfficeDTO: CreateOfficeDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateOffices', 'id', id)
            // verify required parameter 'createOfficeDTO' is not null or undefined
            assertParamExists('updateOffices', 'createOfficeDTO', createOfficeDTO)
            const localVarPath = `/offices/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOfficeDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OfficesApi - functional programming interface
 * @export
 */
export const OfficesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OfficesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateOfficeDTO} createOfficeDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOffices(createOfficeDTO: CreateOfficeDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOfficeDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOffices(createOfficeDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllOffices(limit?: number, offset?: number, where?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllOffices(limit, offset, where, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOneOffices(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOfficeDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOneOffices(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logicDisableOffices(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logicDisableOffices(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {CreateOfficeDTO} createOfficeDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateOffices(id: number, createOfficeDTO: CreateOfficeDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOfficeDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateOffices(id, createOfficeDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OfficesApi - factory interface
 * @export
 */
export const OfficesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OfficesApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateOfficeDTO} createOfficeDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOffices(createOfficeDTO: CreateOfficeDTO, options?: any): AxiosPromise<CreateOfficeDTO> {
            return localVarFp.createOffices(createOfficeDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllOffices(limit?: number, offset?: number, where?: string, options?: any): AxiosPromise<PaginatedResponse> {
            return localVarFp.getAllOffices(limit, offset, where, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneOffices(id: number, options?: any): AxiosPromise<CreateOfficeDTO> {
            return localVarFp.getOneOffices(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logicDisableOffices(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.logicDisableOffices(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {CreateOfficeDTO} createOfficeDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOffices(id: number, createOfficeDTO: CreateOfficeDTO, options?: any): AxiosPromise<CreateOfficeDTO> {
            return localVarFp.updateOffices(id, createOfficeDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OfficesApi - object-oriented interface
 * @export
 * @class OfficesApi
 * @extends {BaseAPI}
 */
export class OfficesApi extends BaseAPI {
    /**
     * 
     * @param {CreateOfficeDTO} createOfficeDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfficesApi
     */
    public createOffices(createOfficeDTO: CreateOfficeDTO, options?: any) {
        return OfficesApiFp(this.configuration).createOffices(createOfficeDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [where] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfficesApi
     */
    public getAllOffices(limit?: number, offset?: number, where?: string, options?: any) {
        return OfficesApiFp(this.configuration).getAllOffices(limit, offset, where, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfficesApi
     */
    public getOneOffices(id: number, options?: any) {
        return OfficesApiFp(this.configuration).getOneOffices(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfficesApi
     */
    public logicDisableOffices(id: number, options?: any) {
        return OfficesApiFp(this.configuration).logicDisableOffices(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {CreateOfficeDTO} createOfficeDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfficesApi
     */
    public updateOffices(id: number, createOfficeDTO: CreateOfficeDTO, options?: any) {
        return OfficesApiFp(this.configuration).updateOffices(id, createOfficeDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SchedulesApi - axios parameter creator
 * @export
 */
export const SchedulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateScheduleDTO} createScheduleDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSchedules: async (createScheduleDTO: CreateScheduleDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createScheduleDTO' is not null or undefined
            assertParamExists('createSchedules', 'createScheduleDTO', createScheduleDTO)
            const localVarPath = `/schedules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createScheduleDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSchedules: async (limit?: number, offset?: number, where?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/schedules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} dateFrom 
         * @param {string} dateEnd 
         * @param {string} specialityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvaliableDatesSchedules: async (dateFrom: string, dateEnd: string, specialityId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'dateFrom' is not null or undefined
            assertParamExists('getAvaliableDatesSchedules', 'dateFrom', dateFrom)
            // verify required parameter 'dateEnd' is not null or undefined
            assertParamExists('getAvaliableDatesSchedules', 'dateEnd', dateEnd)
            // verify required parameter 'specialityId' is not null or undefined
            assertParamExists('getAvaliableDatesSchedules', 'specialityId', specialityId)
            const localVarPath = `/schedules/avaliable`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dateFrom !== undefined) {
                localVarQueryParameter['dateFrom'] = dateFrom;
            }

            if (dateEnd !== undefined) {
                localVarQueryParameter['dateEnd'] = dateEnd;
            }

            if (specialityId !== undefined) {
                localVarQueryParameter['specialityId'] = specialityId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneSchedules: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOneSchedules', 'id', id)
            const localVarPath = `/schedules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logicDisableSchedules: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('logicDisableSchedules', 'id', id)
            const localVarPath = `/schedules/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {CreateScheduleDTO} createScheduleDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSchedules: async (id: number, createScheduleDTO: CreateScheduleDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSchedules', 'id', id)
            // verify required parameter 'createScheduleDTO' is not null or undefined
            assertParamExists('updateSchedules', 'createScheduleDTO', createScheduleDTO)
            const localVarPath = `/schedules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createScheduleDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchedulesApi - functional programming interface
 * @export
 */
export const SchedulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchedulesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateScheduleDTO} createScheduleDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSchedules(createScheduleDTO: CreateScheduleDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateScheduleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSchedules(createScheduleDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSchedules(limit?: number, offset?: number, where?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSchedules(limit, offset, where, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} dateFrom 
         * @param {string} dateEnd 
         * @param {string} specialityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvaliableDatesSchedules(dateFrom: string, dateEnd: string, specialityId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvaliableDatesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvaliableDatesSchedules(dateFrom, dateEnd, specialityId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOneSchedules(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateScheduleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOneSchedules(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logicDisableSchedules(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logicDisableSchedules(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {CreateScheduleDTO} createScheduleDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSchedules(id: number, createScheduleDTO: CreateScheduleDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateScheduleDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSchedules(id, createScheduleDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SchedulesApi - factory interface
 * @export
 */
export const SchedulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchedulesApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateScheduleDTO} createScheduleDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSchedules(createScheduleDTO: CreateScheduleDTO, options?: any): AxiosPromise<CreateScheduleDTO> {
            return localVarFp.createSchedules(createScheduleDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSchedules(limit?: number, offset?: number, where?: string, options?: any): AxiosPromise<PaginatedResponse> {
            return localVarFp.getAllSchedules(limit, offset, where, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} dateFrom 
         * @param {string} dateEnd 
         * @param {string} specialityId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvaliableDatesSchedules(dateFrom: string, dateEnd: string, specialityId: string, options?: any): AxiosPromise<AvaliableDatesResponse> {
            return localVarFp.getAvaliableDatesSchedules(dateFrom, dateEnd, specialityId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneSchedules(id: number, options?: any): AxiosPromise<CreateScheduleDTO> {
            return localVarFp.getOneSchedules(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logicDisableSchedules(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.logicDisableSchedules(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {CreateScheduleDTO} createScheduleDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSchedules(id: number, createScheduleDTO: CreateScheduleDTO, options?: any): AxiosPromise<CreateScheduleDTO> {
            return localVarFp.updateSchedules(id, createScheduleDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchedulesApi - object-oriented interface
 * @export
 * @class SchedulesApi
 * @extends {BaseAPI}
 */
export class SchedulesApi extends BaseAPI {
    /**
     * 
     * @param {CreateScheduleDTO} createScheduleDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public createSchedules(createScheduleDTO: CreateScheduleDTO, options?: any) {
        return SchedulesApiFp(this.configuration).createSchedules(createScheduleDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [where] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public getAllSchedules(limit?: number, offset?: number, where?: string, options?: any) {
        return SchedulesApiFp(this.configuration).getAllSchedules(limit, offset, where, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} dateFrom 
     * @param {string} dateEnd 
     * @param {string} specialityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public getAvaliableDatesSchedules(dateFrom: string, dateEnd: string, specialityId: string, options?: any) {
        return SchedulesApiFp(this.configuration).getAvaliableDatesSchedules(dateFrom, dateEnd, specialityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public getOneSchedules(id: number, options?: any) {
        return SchedulesApiFp(this.configuration).getOneSchedules(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public logicDisableSchedules(id: number, options?: any) {
        return SchedulesApiFp(this.configuration).logicDisableSchedules(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {CreateScheduleDTO} createScheduleDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchedulesApi
     */
    public updateSchedules(id: number, createScheduleDTO: CreateScheduleDTO, options?: any) {
        return SchedulesApiFp(this.configuration).updateSchedules(id, createScheduleDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SpecialitiesApi - axios parameter creator
 * @export
 */
export const SpecialitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateSpecialityDTO} createSpecialityDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpecialities: async (createSpecialityDTO: CreateSpecialityDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createSpecialityDTO' is not null or undefined
            assertParamExists('createSpecialities', 'createSpecialityDTO', createSpecialityDTO)
            const localVarPath = `/specialities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSpecialityDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSpecialities: async (limit?: number, offset?: number, where?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/specialities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneSpecialities: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOneSpecialities', 'id', id)
            const localVarPath = `/specialities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logicDisableSpecialities: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('logicDisableSpecialities', 'id', id)
            const localVarPath = `/specialities/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {CreateSpecialityDTO} createSpecialityDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpecialities: async (id: number, createSpecialityDTO: CreateSpecialityDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSpecialities', 'id', id)
            // verify required parameter 'createSpecialityDTO' is not null or undefined
            assertParamExists('updateSpecialities', 'createSpecialityDTO', createSpecialityDTO)
            const localVarPath = `/specialities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createSpecialityDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SpecialitiesApi - functional programming interface
 * @export
 */
export const SpecialitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SpecialitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateSpecialityDTO} createSpecialityDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSpecialities(createSpecialityDTO: CreateSpecialityDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSpecialityDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSpecialities(createSpecialityDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllSpecialities(limit?: number, offset?: number, where?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllSpecialities(limit, offset, where, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOneSpecialities(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSpecialityDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOneSpecialities(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logicDisableSpecialities(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logicDisableSpecialities(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {CreateSpecialityDTO} createSpecialityDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSpecialities(id: number, createSpecialityDTO: CreateSpecialityDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateSpecialityDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSpecialities(id, createSpecialityDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SpecialitiesApi - factory interface
 * @export
 */
export const SpecialitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SpecialitiesApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateSpecialityDTO} createSpecialityDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSpecialities(createSpecialityDTO: CreateSpecialityDTO, options?: any): AxiosPromise<CreateSpecialityDTO> {
            return localVarFp.createSpecialities(createSpecialityDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllSpecialities(limit?: number, offset?: number, where?: string, options?: any): AxiosPromise<PaginatedResponse> {
            return localVarFp.getAllSpecialities(limit, offset, where, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneSpecialities(id: number, options?: any): AxiosPromise<CreateSpecialityDTO> {
            return localVarFp.getOneSpecialities(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logicDisableSpecialities(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.logicDisableSpecialities(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {CreateSpecialityDTO} createSpecialityDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSpecialities(id: number, createSpecialityDTO: CreateSpecialityDTO, options?: any): AxiosPromise<CreateSpecialityDTO> {
            return localVarFp.updateSpecialities(id, createSpecialityDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SpecialitiesApi - object-oriented interface
 * @export
 * @class SpecialitiesApi
 * @extends {BaseAPI}
 */
export class SpecialitiesApi extends BaseAPI {
    /**
     * 
     * @param {CreateSpecialityDTO} createSpecialityDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpecialitiesApi
     */
    public createSpecialities(createSpecialityDTO: CreateSpecialityDTO, options?: any) {
        return SpecialitiesApiFp(this.configuration).createSpecialities(createSpecialityDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [where] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpecialitiesApi
     */
    public getAllSpecialities(limit?: number, offset?: number, where?: string, options?: any) {
        return SpecialitiesApiFp(this.configuration).getAllSpecialities(limit, offset, where, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpecialitiesApi
     */
    public getOneSpecialities(id: number, options?: any) {
        return SpecialitiesApiFp(this.configuration).getOneSpecialities(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpecialitiesApi
     */
    public logicDisableSpecialities(id: number, options?: any) {
        return SpecialitiesApiFp(this.configuration).logicDisableSpecialities(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {CreateSpecialityDTO} createSpecialityDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SpecialitiesApi
     */
    public updateSpecialities(id: number, createSpecialityDTO: CreateSpecialityDTO, options?: any) {
        return SpecialitiesApiFp(this.configuration).updateSpecialities(id, createSpecialityDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePasswordMailUsers: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('changePasswordMailUsers', 'id', id)
            const localVarPath = `/users/{id}/password/mail`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateUserDTO} createUserDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsers: async (createUserDTO: CreateUserDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createUserDTO' is not null or undefined
            assertParamExists('createUsers', 'createUserDTO', createUserDTO)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: async (limit?: number, offset?: number, where?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (where !== undefined) {
                localVarQueryParameter['where'] = where;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneUsers: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOneUsers', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logicDisableUsers: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('logicDisableUsers', 'id', id)
            const localVarPath = `/users/{id}/disable`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdatePasswordDTO} updatePasswordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePasswordUsers: async (id: number, updatePasswordDTO: UpdatePasswordDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePasswordUsers', 'id', id)
            // verify required parameter 'updatePasswordDTO' is not null or undefined
            assertParamExists('updatePasswordUsers', 'updatePasswordDTO', updatePasswordDTO)
            const localVarPath = `/users/{id}/password`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePasswordDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStatusUsers: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateStatusUsers', 'id', id)
            const localVarPath = `/users/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateUserDTO} updateUserDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsers: async (id: number, updateUserDTO: UpdateUserDTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUsers', 'id', id)
            // verify required parameter 'updateUserDTO' is not null or undefined
            assertParamExists('updateUsers', 'updateUserDTO', updateUserDTO)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePasswordMailUsers(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePasswordMailUsers(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateUserDTO} createUserDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUsers(createUserDTO: CreateUserDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUsers(createUserDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsers(limit?: number, offset?: number, where?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsers(limit, offset, where, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOneUsers(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOneUsers(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logicDisableUsers(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logicDisableUsers(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdatePasswordDTO} updatePasswordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePasswordUsers(id: number, updatePasswordDTO: UpdatePasswordDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePasswordUsers(id, updatePasswordDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStatusUsers(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStatusUsers(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateUserDTO} updateUserDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUsers(id: number, updateUserDTO: UpdateUserDTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUsers(id, updateUserDTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePasswordMailUsers(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.changePasswordMailUsers(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateUserDTO} createUserDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsers(createUserDTO: CreateUserDTO, options?: any): AxiosPromise<CreateUserResponse> {
            return localVarFp.createUsers(createUserDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [where] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(limit?: number, offset?: number, where?: string, options?: any): AxiosPromise<PaginatedResponse> {
            return localVarFp.getAllUsers(limit, offset, where, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOneUsers(id: number, options?: any): AxiosPromise<CreateUserDTO> {
            return localVarFp.getOneUsers(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logicDisableUsers(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.logicDisableUsers(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdatePasswordDTO} updatePasswordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePasswordUsers(id: number, updatePasswordDTO: UpdatePasswordDTO, options?: any): AxiosPromise<void> {
            return localVarFp.updatePasswordUsers(id, updatePasswordDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStatusUsers(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.updateStatusUsers(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {UpdateUserDTO} updateUserDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUsers(id: number, updateUserDTO: UpdateUserDTO, options?: any): AxiosPromise<CreateUserResponse> {
            return localVarFp.updateUsers(id, updateUserDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public changePasswordMailUsers(id: number, options?: any) {
        return UsersApiFp(this.configuration).changePasswordMailUsers(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateUserDTO} createUserDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUsers(createUserDTO: CreateUserDTO, options?: any) {
        return UsersApiFp(this.configuration).createUsers(createUserDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [where] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getAllUsers(limit?: number, offset?: number, where?: string, options?: any) {
        return UsersApiFp(this.configuration).getAllUsers(limit, offset, where, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getOneUsers(id: number, options?: any) {
        return UsersApiFp(this.configuration).getOneUsers(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public logicDisableUsers(id: number, options?: any) {
        return UsersApiFp(this.configuration).logicDisableUsers(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {UpdatePasswordDTO} updatePasswordDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updatePasswordUsers(id: number, updatePasswordDTO: UpdatePasswordDTO, options?: any) {
        return UsersApiFp(this.configuration).updatePasswordUsers(id, updatePasswordDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateStatusUsers(id: number, options?: any) {
        return UsersApiFp(this.configuration).updateStatusUsers(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {UpdateUserDTO} updateUserDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUsers(id: number, updateUserDTO: UpdateUserDTO, options?: any) {
        return UsersApiFp(this.configuration).updateUsers(id, updateUserDTO, options).then((request) => request(this.axios, this.basePath));
    }
}


